{"name": "Graphs game", "version": "0.1", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Graphs game-0.1-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": -1, "objects": [{"type": "lean", "content": "3", "hidden": false}, {"type": "text", "content": "4"}, {"type": "lean", "content": "5", "hidden": false}, {"type": "text", "content": "6"}, {"type": "lean", "content": "7", "hidden": false}, {"type": "text", "content": "8"}, {"type": "lean", "content": "9", "hidden": false}, {"type": "text", "content": "10"}, {"type": "lean", "content": "11", "hidden": false}, {"type": "text", "content": "12"}, {"type": "lean", "content": "13", "hidden": false}, {"type": "text", "content": "14"}, {"type": "lean", "content": "15", "hidden": false}, {"type": "text", "content": "16"}, {"type": "lean", "content": "17", "hidden": false}, {"type": "text", "content": "18"}, {"type": "lean", "content": "19", "hidden": false}, {"type": "text", "content": "20"}, {"type": "lean", "content": "21", "hidden": false}, {"type": "text", "content": "22"}, {"type": "lean", "content": "23", "hidden": false}, {"type": "text", "content": "24"}, {"type": "lean", "content": "25", "hidden": false}, {"type": "text", "content": "26"}, {"type": "lean", "content": "27", "hidden": false}, {"type": "text", "content": "28"}, {"type": "lean", "content": "29", "hidden": false}, {"type": "text", "content": "30"}, {"type": "lean", "content": "31", "hidden": false}, {"type": "text", "content": "32"}, {"type": "lean", "content": "33", "hidden": false}, {"type": "text", "content": "34"}, {"type": "lean", "content": "35", "hidden": false}]}]}], "texts": [["Graphs game", "# The Natural Number Game, version 1.3.3\n## By Kevin Buzzard and Mohammad Pedramfar. \n# What is this game?\nWelcome to the natural number game -- a part-book part-game which shows the power of induction.\nBlue nodes on the graph are ones that you are ready to enter. Grey nodes you should stay away\nfrom -- a grey node turns blue when *all* nodes above it are complete. Green nodes are completed.\n(Actually you can try any level at any time, but you might not know enough to complete it if it's grey).\nIn this game, you get own version of the natural numbers, called `mynat`, in an interactive\ntheorem prover called Lean. Your version of the natural numbers satisfies something called\nthe principle of mathematical induction, and a couple of other things too (Peano's axioms).\nUnfortunately, nobody has proved any theorems about these\nnatural numbers yet! For example, addition will be defined for you,\nbut nobody has proved that `x + y = y + x` yet. This is your job. You're going to\nprove mathematical theorems using the Lean theorem prover. In other words, you're going to solve\nlevels in a computer game.\nYou're going to prove these theorems using *tactics*. The introductory world, Tutorial World,\nwill take you through some of these tactics. During your proofs, your \"goal\" (i.e. what you're\nsupposed to be proving) will be displayed with  a `\u22a2` symbol in front of it. If the top\nright hand box reports \"Theorem Proved!\", you have closed all the goals in the level\nand can move on to the next level in the world you're in. When you've finished a world,\nhit \"main menu\" in the top left to get back here.\nFor more info, see the <a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/FAQ.html\" target=\"blank\">FAQ</a>.\n# What's new in v1.3?\nThe game now saves your progress! Thanks to everyone who asked for it,\nand to Mohammad for making it happen :-)\nCute little clipboard to copy your solutions.\n# Thanks\nSpecial thanks to Rob Lewis for tactic hackery, Bryan Gin-Ge Chen for\njavascript hackery, Patrick Massot for his\n<a href=\"https://github.com/leanprover-community/format_lean\" target=\"blank\">Lean to html formatter</a>,\nSian Carey for Power World,\nand, last but not least, all the people who fed back comments, including\nthe 2019-20 Imperial College 1st year maths beta tester students, Marie-Am\u00e9lie Lawn,\nToby Gee, Joseph Myers, and all the people who have been in touch\nvia the <a href=\"https://leanprover.zulipchat.com/\" target=\"blank\">Lean Zulip chat</a>\n or the <a href=\"https://xenaproject.wordpress.com/\" target=\"blank\">Xena Project blog</a>\n or via <a href=\"https://twitter.com/XenaProject\" target=\"blank\">Twitter</a>.\nThe natural number game is brought to you by the Xena project, a project based at Imperial College London\nwhose aim is to get mathematics undergraduates using computer theorem provers.\nLean is a computer theorem prover being developed at Microsoft Research.\nProve a theorem. Write a function. <a href=\"https://twitter.com/XenaProject\" target=\"blank\">@XenaProject</a>.\n", "Morphisms world", "import data.sym2\nopen function\n", "We begin by defining a graph as a triple:\n- vertices;\n- edges;\n- and an endpoint map taking each edge to the unordered pair of its endpoints.\n", "structure graph :=\n  (vertices : Type)\n  (edges : Type)\n  (endpoints : edges \u2192 sym2 vertices)\n", "This theorem is a sanity check to see that sym2 works as we want.\n", "theorem endpoint_sym (G : graph) (a b : G.vertices) : \u27e6(a,b)\u27e7 = \u27e6(b,a)\u27e7 :=\nbegin\n  exact sym2.eq_swap,\nend\n", "Now we can define adjacency.\n", "def are_adjacent (G : graph) (a b : G.vertices) : Prop := \u2203 e : G.edges, G.endpoints(e) = \u27e6(a,b)\u27e7\n", "We now define a morphism of graphs to be a triple:\n- a map on vertices;\n- a map on edges;\n- and a compatability condition between the two maps.\n", "structure morphism (G : graph) (H : graph) :=\n  (vertex_map : G.vertices \u2192 H.vertices)\n  (edge_map : G.edges \u2192 H.edges)\n  (compatability : H.endpoints \u2218 edge_map = sym2.map vertex_map \u2218 G.endpoints)\n", "I want a convenient infix notation for a morphism.\nI tried to overload the usual \u2192 arrow, but Lean got confused\n(or probably I did it incorrectly).\n", "infix `\u21a6` :50 := morphism\n", "We want to define composition of morphisms, but we need to prove that the\ncompatability condition needed holds when we do the `obvious' thing ...\n", "theorem compatability {G H K : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) : K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints :=\nbegin\n  calc K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = (sym2.map \u03b2.vertex_map \u2218 H.endpoints) \u2218 \u03b1.edge_map : by rw \u2190 \u03b2.compatability\n                                         ... = sym2.map \u03b2.vertex_map \u2218 (sym2.map \u03b1.vertex_map \u2218 G.endpoints) : by rw \u2190 \u03b1.compatability\n                                         ... = (sym2.map \u03b2.vertex_map \u2218 sym2.map \u03b1.vertex_map) \u2218 G.endpoints : by refl\n                                         ... = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints : by rw \u2190 sym2.map_comp,\nend\n", "Now that we know the compatability condition holds, we can go ahead and \ndefine composition of morphisms.\n", "def compose {G H K : graph} (\u03b2 : H \u21a6 K) (\u03b1 : G \u21a6 H) : G \u21a6 K :=\n  morphism.mk (\u03b2.vertex_map \u2218 \u03b1.vertex_map) (\u03b2.edge_map \u2218 \u03b1.edge_map) (by exact compatability \u03b1 \u03b2)\n", "We want a convenient infix operator for composition of morphisms.\nAfter my experience of trying to overload \u2192 I decided not to even attempt\nto overload \u2218.\n", "infix `\u229a`:80 := compose\n", "Proving associativity of composition is now trivial ...\n", "theorem mor_assoc {G H K L : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) (\u03b3 : K \u21a6 L) : \u03b3 \u229a (\u03b2 \u229a \u03b1) = (\u03b3 \u229a \u03b2) \u229a \u03b1 :=\nbegin\n  refl,\nend\n", "We want to define the identity morphism, but that requires a compatability proof.\n", "theorem id_compatability (G : graph) : G.endpoints \u2218 id = sym2.map id \u2218 G.endpoints :=\nbegin\n  rw sym2.map_id,\n  refl,\nend\n", "Now we can define the identity morphism.\n", "def \ud835\udd40 (G : graph) : G \u21a6 G :=\n  morphism.mk (id) (id) (by exact id_compatability G)\n", "Next we turn our attention to defining an isomorphism.\n", "def isomorphism {G H : graph} (\u03b1 : G \u21a6 H) : Prop :=\n  \u2203 \u03b2 : H \u21a6 G, \u03b1 \u229a \u03b2 = \ud835\udd40 H \u2227 \u03b2 \u229a \u03b1 = \ud835\udd40 G\n", "This is a sanity check: proving that the identity is an isomorphism.\n", "theorem id_is_iso (G : graph) : isomorphism (\ud835\udd40 G) :=\nbegin\n  use \ud835\udd40 G,\n  split,\n  refl,\n  refl,\nend\n", "Proving equality on structures is a pain, so we should prove an extensionality\ntheorem.  Basically, it suffices for the respective vertex maps and edge maps to \nbe equal.\n", "theorem mor_ext {G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hv : \u03b1.vertex_map = \u03b2.vertex_map) (he : \u03b1.edge_map = \u03b2.edge_map) : \u03b1 = \u03b2 :=\nbegin\n  cases \u03b1,\n  cases \u03b2,\n  rw morphism.mk.inj_eq,\n  exact \u27e8hv, he\u27e9,\nend\n", "The next two are helpful so that we don't have to keep repeating silly proofs.\nBasically, we show that equal morphisms have equal vertex maps and edge maps.\n", "theorem eq_mor_eq_vmap {G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hyp : \u03b1 = \u03b2) : \u03b1.vertex_map = \u03b2.vertex_map :=\nbegin\n  cases \u03b1,\n  cases \u03b2,\n  rw morphism.mk.inj_eq at hyp,\n  exact hyp.1,\nend\ntheorem eq_mor_eq_emap {G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hyp : \u03b1 = \u03b2) : \u03b1.edge_map = \u03b2.edge_map :=\nbegin\n  cases \u03b1,\n  cases \u03b2,\n  rw morphism.mk.inj_eq at hyp,\n  exact hyp.2,\nend\n", "Our final two results are proving that a morphism is an isomorphism if and\nonly if the vertex map and edge map are both bijective.  Of course, we are\nleaning very heavily on the corresponding results for functions.\n", "theorem iso.bij {G H : graph} (\u03b1 : G \u21a6 H) (hyp : isomorphism \u03b1) : bijective \u03b1.vertex_map \u2227 bijective \u03b1.edge_map :=\nbegin\n  cases hyp with \u03b2 h\u03b2,\n  cases h\u03b2 with h\u2081 h\u2082,\n  split,\n  split,\n  have h\u2083 : left_inverse \u03b2.vertex_map \u03b1.vertex_map,\n  {\n    intro x,\n    calc \u03b2.vertex_map (\u03b1.vertex_map x) = (\u03b2 \u229a \u03b1).vertex_map x : by refl\n                                   ... = (\ud835\udd40 G).vertex_map x : by rw eq_mor_eq_vmap (\u03b2 \u229a \u03b1) (\ud835\udd40 G) (h\u2082)\n                                   ... = x : by refl,\n  },\n  apply left_inverse.injective h\u2083,\n  have h\u2083 : right_inverse \u03b2.vertex_map \u03b1.vertex_map,\n  {\n    intro x,\n    calc \u03b1.vertex_map (\u03b2.vertex_map x) = (\u03b1 \u229a \u03b2).vertex_map x : by refl\n                                   ... = (\ud835\udd40 H).vertex_map x : by rw eq_mor_eq_vmap (\u03b1 \u229a \u03b2) (\ud835\udd40 H) (h\u2081)\n                                   ... = x : by refl,\n  },\n  apply right_inverse.surjective h\u2083,\n  split,\n  have h\u2083 : left_inverse \u03b2.edge_map \u03b1.edge_map,\n  {\n    intro x,\n    calc \u03b2.edge_map (\u03b1.edge_map x) = (\u03b2 \u229a \u03b1).edge_map x : by refl\n                                   ... = (\ud835\udd40 G).edge_map x : by rw eq_mor_eq_emap (\u03b2 \u229a \u03b1) (\ud835\udd40 G) (h\u2082)\n                                   ... = x : by refl,\n  },\n  apply left_inverse.injective h\u2083,\n  have h\u2083 : right_inverse \u03b2.edge_map \u03b1.edge_map,\n  {\n    intro x,\n    calc \u03b1.edge_map (\u03b2.edge_map x) = (\u03b1 \u229a \u03b2).edge_map x : by refl\n                                   ... = (\ud835\udd40 H).edge_map x : by rw eq_mor_eq_emap (\u03b1 \u229a \u03b2) (\ud835\udd40 H) (h\u2081)\n                                   ... = x : by refl,\n  },\n  apply right_inverse.surjective h\u2083,\nend\ntheorem bij.iso {G H : graph} (\u03b1 : G \u21a6 H) (hv : bijective \u03b1.vertex_map) (he : bijective \u03b1.edge_map) : isomorphism \u03b1 :=\nbegin\n  let \u03c6 := \u03b1.vertex_map,\n  let \u03c8 := \u03b1.edge_map,\n  rw bijective_iff_has_inverse at hv,\n  cases hv with \u03c6' h\u03c6',\n  rw bijective_iff_has_inverse at he,\n  cases he with \u03c8' h\u03c8',\n  have comp' : G.endpoints \u2218 \u03c8' = sym2.map \u03c6' \u2218 H.endpoints,\n  {\n    calc G.endpoints \u2218 \u03c8' = id \u2218 G.endpoints \u2218 \u03c8' : by refl\n                      ... = sym2.map id \u2218 G.endpoints \u2218 \u03c8' : by rw sym2.map_id\n                      ... = sym2.map (\u03c6' \u2218 \u03c6) \u2218 G.endpoints \u2218 \u03c8' : by rw left_inverse.id h\u03c6'.1\n                      ... = sym2.map \u03c6' \u2218 sym2.map \u03c6 \u2218 G.endpoints \u2218 \u03c8' : by rw sym2.map_comp\n                      ... = sym2.map \u03c6' \u2218 (H.endpoints \u2218 \u03c8) \u2218 \u03c8' : by rw \u03b1.compatability\n                      ... = sym2.map \u03c6' \u2218 H.endpoints \u2218 (\u03c8 \u2218 \u03c8') : by refl\n                      ... = sym2.map \u03c6' \u2218 H.endpoints \u2218 id : by rw right_inverse.id h\u03c8'.2\n                      ... = sym2.map \u03c6' \u2218 H.endpoints : by refl,\n  },\n  let \u03b2 := morphism.mk (\u03c6') (\u03c8') (comp'),\n  use \u03b2,\n  split,\n  {\n    apply mor_ext,\n    {\n      calc (\u03b1 \u229a \u03b2).vertex_map = \u03b1.vertex_map \u2218 \u03b2.vertex_map : by refl\n                          ... = \u03c6 \u2218 \u03c6' : by refl\n                          ... = id : by exact left_inverse.id h\u03c6'.2\n                          ... = (\ud835\udd40 H).vertex_map : by refl,\n    },\n    {\n      calc (\u03b1 \u229a \u03b2).edge_map = \u03b1.edge_map \u2218 \u03b2.edge_map : by refl\n                          ... = \u03c8 \u2218 \u03c8' : by refl\n                          ... = id : by exact left_inverse.id h\u03c8'.2\n                          ... = (\ud835\udd40 H).edge_map : by refl,\n    },\n  },\n  {\n    apply mor_ext,\n    {\n      calc (\u03b2 \u229a \u03b1).vertex_map = \u03b2.vertex_map \u2218 \u03b1.vertex_map : by refl\n                          ... = \u03c6' \u2218 \u03c6 : by refl\n                          ... = id : by exact left_inverse.id h\u03c6'.1\n                          ... = (\ud835\udd40 G).vertex_map : by refl,\n    },\n    {\n      calc (\u03b2 \u229a \u03b1).edge_map = \u03b2.edge_map \u2218 \u03b1.edge_map : by refl\n                          ... = \u03c8' \u2218 \u03c8 : by refl\n                          ... = id : by exact left_inverse.id h\u03c8'.1\n                          ... = (\ud835\udd40 G).edge_map : by refl,\n    },\n  },\nend"]]}