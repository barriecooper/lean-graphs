{"name": "Graphs game", "version": "0.1", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Graphs game-0.1-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "3", "hidden": false}, {"type": "text", "content": "4"}, {"type": "lean", "content": "5", "hidden": false}, {"type": "text", "content": "6"}, {"type": "lean", "content": "7", "hidden": false}, {"type": "text", "content": "8"}, {"type": "lean", "content": "9", "hidden": false}, {"type": "text", "content": "10"}, {"type": "lean", "content": "11", "hidden": false}, {"type": "text", "content": "12"}, {"type": "lemma", "text": "13", "lean": "lemma compatability {G H K : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) : K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints :=\n", "sideBar": true, "firstProofLineNumber": 51, "lastProofLineNumber": 51, "textBefore": "import data.sym2 -- allows us to use unordered pairs\n\n/-\nWe begin by defining a graph as a triple:\n- vertices;\n- edges;\n- and an endpoint map taking each edge to the unordered pair of its endpoints.\n-/\n\nstructure graph :=\n  (vertices : Type)\n  (edges : Type)\n  (endpoints : edges \u2192 sym2 vertices)\n\n/-\nNow we can define adjacency.\n-/\n\ndef are_adjacent (G : graph) (a b : G.vertices) : Prop := \u2203 e : G.edges, G.endpoints(e) = \u27e6(a,b)\u27e7\n\n/-\nWe now define a morphism of graphs to be a triple:\n- a map on vertices;\n- a map on edges;\n- and a compatability condition between the two maps.\n-/\n\nstructure morphism (G : graph) (H : graph) :=\n  (vertex_map : G.vertices \u2192 H.vertices)\n  (edge_map : G.edges \u2192 H.edges)\n  (compatability : H.endpoints \u2218 edge_map = sym2.map vertex_map \u2218 G.endpoints)\n\n/-\nWe want a convenient infix notation for a morphism.\n-/\n\ninfix `\u21a6` :50 := morphism\n\n/-\nWe want to define composition of morphisms, so your first task is to prove that the\ncompatability condition needed holds when we do the `obvious' thing ... you will want \nto use the result sym2.map_comp.\n-/\n\n/- Lemma :\nFor all graphs $G$, $H$ and $K$ and for all morphisms $\u03b1 : G \u2192 H$ and $\u03b2 : H \u2192 K$, we have\n$\u03b5_K \u2218 \u03b2_e \u2218 \u03b1_e = sym2 (\u03b2_v \u2218 \u03b1_v) \u2218 \u03b5_G$.\n-/\nlemma compatability {G H K : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) : K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints :=\nbegin\n", "proof": "  sorry,", "textAfter": "\nend", "height": 1, "editorText": "sorry", "lineOffset": 50, "name": "compatability", "statement": "{G H K : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) : K.endpoints \u2218 \u03b2.edge_map \u2218 \u03b1.edge_map = sym2.map (\u03b2.vertex_map \u2218 \u03b1.vertex_map) \u2218 G.endpoints"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "14", "hidden": false}, {"type": "text", "content": "15"}, {"type": "lean", "content": "16", "hidden": false}, {"type": "text", "content": "17"}, {"type": "lean", "content": "18", "hidden": false}, {"type": "text", "content": "19"}, {"type": "lemma", "text": "20", "lean": "lemma mor_assoc {G H K L : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) (\u03b3 : K \u21a6 L) : \u03b3 \u229a (\u03b2 \u229a \u03b1) = (\u03b3 \u229a \u03b2) \u229a \u03b1 :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 27, "textBefore": "import graphs.definitions\n\n/-\nNow that we know the compatability condition holds, we can go ahead and \ndefine composition of morphisms.\n-/\n\ndef compose {G H K : graph} (\u03b2 : H \u21a6 K) (\u03b1 : G \u21a6 H) : G \u21a6 K :=\n  morphism.mk (\u03b2.vertex_map \u2218 \u03b1.vertex_map) (\u03b2.edge_map \u2218 \u03b1.edge_map) (by exact compatability \u03b1 \u03b2)\n\n/-\nWe want a convenient infix operator for composition of morphisms.\n-/\n\ninfix `\u229a`:80 := compose\n\n/-\nProving associativity of composition is now trivial ...\n-/\n\n/- Lemma :\nFor all morphisms $\u03b1 : G \u2192 H$, $\u03b2 : H \u2192 K$ and $\u03b3 : K \u2192 L$, we have\n$\u03b3 \u2218 (\u03b2 \u2218 \u03b1) = (\u03b3 \u2218 \u03b2) \u2218 \u03b1$.\n-/\nlemma mor_assoc {G H K L : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) (\u03b3 : K \u21a6 L) : \u03b3 \u229a (\u03b2 \u229a \u03b1) = (\u03b3 \u229a \u03b2) \u229a \u03b1 :=\nbegin\n", "proof": "  sorry,", "textAfter": "\nend\n", "height": 1, "editorText": "sorry", "lineOffset": 26, "name": "mor_assoc", "statement": "{G H K L : graph} (\u03b1 : G \u21a6 H) (\u03b2 : H \u21a6 K) (\u03b3 : K \u21a6 L) : \u03b3 \u229a (\u03b2 \u229a \u03b1) = (\u03b3 \u229a \u03b2) \u229a \u03b1"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "21", "hidden": false}, {"type": "text", "content": "22"}, {"type": "lemma", "text": "23", "lean": "lemma id_compatability (G : graph) : G.endpoints \u2218 id = sym2.map id \u2218 G.endpoints :=\n", "sideBar": true, "firstProofLineNumber": 12, "lastProofLineNumber": 12, "textBefore": "import graphs.composition\n\n/-\nWe want to define the identity morphism, but that requires a compatability proof.  \nYou will need to use sym2.map_id.\n-/\n\n/- Lemma : The identity maps on vertices and edges satisfy the compatability condition.\n-/\nlemma id_compatability (G : graph) : G.endpoints \u2218 id = sym2.map id \u2218 G.endpoints :=\nbegin\n", "proof": "  sorry,", "textAfter": "\nend\n", "height": 1, "editorText": "sorry", "lineOffset": 11, "name": "id_compatability", "statement": "(G : graph) : G.endpoints \u2218 id = sym2.map id \u2218 G.endpoints"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "24", "hidden": false}, {"type": "text", "content": "25"}, {"type": "lean", "content": "26", "hidden": false}, {"type": "text", "content": "27"}, {"type": "lean", "content": "28", "hidden": false}, {"type": "text", "content": "29"}, {"type": "lemma", "text": "30", "lean": "lemma id_is_iso (G : graph) : isomorphism (\ud835\udd40 G) :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 24, "textBefore": "import graphs.id\n\n/-\nNow we can define the identity morphism.\n-/\n\ndef \ud835\udd40 (G : graph) : G \u21a6 G :=\n  morphism.mk (id) (id) (by exact id_compatability G)\n\n/-\nNext we turn our attention to defining an isomorphism.\n-/\n\ndef isomorphism {G H : graph} (\u03b1 : G \u21a6 H) : Prop :=\n  \u2203 \u03b2 : H \u21a6 G, \u03b1 \u229a \u03b2 = \ud835\udd40 H \u2227 \u03b2 \u229a \u03b1 = \ud835\udd40 G\n\n/-\nThis is a sanity check: proving that the identity is an isomorphism.\n-/\n/- Lemma : The identity morphism is an isomorphism.\n-/\nlemma id_is_iso (G : graph) : isomorphism (\ud835\udd40 G) :=\nbegin\n", "proof": "  sorry,", "textAfter": "\nend\n", "height": 1, "editorText": "sorry", "lineOffset": 23, "name": "id_is_iso", "statement": "(G : graph) : isomorphism (\ud835\udd40 G)"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "31", "hidden": false}, {"type": "text", "content": "32"}, {"type": "lemma", "text": "33", "lean": "lemma mor_ext {G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hv : \u03b1.vertex_map = \u03b2.vertex_map) (he : \u03b1.edge_map = \u03b2.edge_map) : \u03b1 = \u03b2 :=\n", "sideBar": true, "firstProofLineNumber": 15, "lastProofLineNumber": 15, "textBefore": "import graphs.iso\n\n/-\nProving equality on structures is a pain, so we should prove an extensionality\ntheorem.  Basically, it suffices for the respective vertex maps and edge maps to \nbe equal.\n\nYou will need to use cases to write out \u03b1 and \u03b2, and then rewrite with \nmorphism.mk.inj_eq, which splits the equality of structures into separate goals.\n-/\n/- Lemma : \n-/\nlemma mor_ext {G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hv : \u03b1.vertex_map = \u03b2.vertex_map) (he : \u03b1.edge_map = \u03b2.edge_map) : \u03b1 = \u03b2 :=\nbegin\n", "proof": "  sorry,", "textAfter": "\nend\n", "height": 1, "editorText": "sorry", "lineOffset": 14, "name": "mor_ext", "statement": "{G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hv : \u03b1.vertex_map = \u03b2.vertex_map) (he : \u03b1.edge_map = \u03b2.edge_map) : \u03b1 = \u03b2"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "34", "hidden": false}, {"type": "text", "content": "35"}, {"type": "lemma", "text": "36", "lean": "lemma eq_mor_eq_vmap {G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hyp : \u03b1 = \u03b2) : \u03b1.vertex_map = \u03b2.vertex_map :=\n", "sideBar": true, "firstProofLineNumber": 13, "lastProofLineNumber": 13, "textBefore": "import graphs.ext\n\n/-\nThe next two are helpful so that we don't have to keep repeating silly proofs.\nBasically, we show that equal morphisms have equal vertex maps and edge maps \nusing essentially the same argument as for our more general extensionality \ntheorem.\n-/\n/- Lemma :\n-/\nlemma eq_mor_eq_vmap {G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hyp : \u03b1 = \u03b2) : \u03b1.vertex_map = \u03b2.vertex_map :=\nbegin\n", "proof": "  sorry,", "textAfter": "\nend\n", "height": 1, "editorText": "sorry", "lineOffset": 12, "name": "eq_mor_eq_vmap", "statement": "{G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hyp : \u03b1 = \u03b2) : \u03b1.vertex_map = \u03b2.vertex_map"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "37", "hidden": false}, {"type": "text", "content": "38"}, {"type": "lemma", "text": "39", "lean": "lemma eq_mor_eq_emap {G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hyp : \u03b1 = \u03b2) : \u03b1.edge_map = \u03b2.edge_map :=\n", "sideBar": true, "firstProofLineNumber": 10, "lastProofLineNumber": 10, "textBefore": "import graphs.ext\n\n/-\nWe prove the same for vertex maps ...\n-/\n/- Lemma : \n-/\nlemma eq_mor_eq_emap {G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hyp : \u03b1 = \u03b2) : \u03b1.edge_map = \u03b2.edge_map :=\nbegin\n", "proof": "  sorry,", "textAfter": "\nend", "height": 1, "editorText": "sorry", "lineOffset": 9, "name": "eq_mor_eq_emap", "statement": "{G H : graph} (\u03b1 : G \u21a6 H) (\u03b2 : G \u21a6 H) (hyp : \u03b1 = \u03b2) : \u03b1.edge_map = \u03b2.edge_map"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "40", "hidden": false}, {"type": "text", "content": "41"}, {"type": "lemma", "text": "42", "lean": "lemma iso.bij {G H : graph} (\u03b1 : G \u21a6 H) (hyp : isomorphism \u03b1) : bijective \u03b1.vertex_map \u2227 bijective \u03b1.edge_map :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 16, "textBefore": "import graphs.allexts\nopen function -- allows us to use key results about functions\n\n/-\nOur final two results are proving that a morphism is an isomorphism if and\nonly if the vertex map and edge map are both bijective.  Of course, we are\nleaning very heavily on the corresponding results for functions.\n\nYou will probably want to use the definitions of left_inverse and right_inverse \nand to apply the results left_inverse.injective and right_inverse.surjective.\n-/\n/- Lemma :\n-/\nlemma iso.bij {G H : graph} (\u03b1 : G \u21a6 H) (hyp : isomorphism \u03b1) : bijective \u03b1.vertex_map \u2227 bijective \u03b1.edge_map :=\nbegin\n", "proof": "  sorry,", "textAfter": "\nend\n", "height": 1, "editorText": "sorry", "lineOffset": 15, "name": "iso.bij", "statement": "{G H : graph} (\u03b1 : G \u21a6 H) (hyp : isomorphism \u03b1) : bijective \u03b1.vertex_map \u2227 bijective \u03b1.edge_map"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "43", "hidden": false}, {"type": "text", "content": "44"}, {"type": "lemma", "text": "45", "lean": "lemma bij.iso {G H : graph} (\u03b1 : G \u21a6 H) (hv : bijective \u03b1.vertex_map) (he : bijective \u03b1.edge_map) : isomorphism \u03b1 :=\n", "sideBar": true, "firstProofLineNumber": 11, "lastProofLineNumber": 11, "textBefore": "import graphs.allexts\nopen function -- allows us to use key results about functions\n\n/-\n... and now for the converse ...\n-/\n/- Lemma :\n-/\nlemma bij.iso {G H : graph} (\u03b1 : G \u21a6 H) (hv : bijective \u03b1.vertex_map) (he : bijective \u03b1.edge_map) : isomorphism \u03b1 :=\nbegin\n", "proof": "  sorry,", "textAfter": "\nend", "height": 1, "editorText": "sorry", "lineOffset": 10, "name": "bij.iso", "statement": "{G H : graph} (\u03b1 : G \u21a6 H) (hv : bijective \u03b1.vertex_map) (he : bijective \u03b1.edge_map) : isomorphism \u03b1"}]}]}], "texts": [["Graphs game", "# The Graphs Game, version 0.1\n## Barrie Cooper. \nThis game uses Lean to prove various results about graphs and is \nbased on the course MTH3022 Graphs, Networks and Algorithms at the \nUniversity of Exeter.\n", "Morphisms world", "import data.sym2 -- allows us to use unordered pairs\n", "We begin by defining a graph as a triple:\n- vertices;\n- edges;\n- and an endpoint map taking each edge to the unordered pair of its endpoints.\n", "structure graph :=\n  (vertices : Type)\n  (edges : Type)\n  (endpoints : edges \u2192 sym2 vertices)\n", "Now we can define adjacency.\n", "def are_adjacent (G : graph) (a b : G.vertices) : Prop := \u2203 e : G.edges, G.endpoints(e) = \u27e6(a,b)\u27e7\n", "We now define a morphism of graphs to be a triple:\n- a map on vertices;\n- a map on edges;\n- and a compatability condition between the two maps.\n", "structure morphism (G : graph) (H : graph) :=\n  (vertex_map : G.vertices \u2192 H.vertices)\n  (edge_map : G.edges \u2192 H.edges)\n  (compatability : H.endpoints \u2218 edge_map = sym2.map vertex_map \u2218 G.endpoints)\n", "We want a convenient infix notation for a morphism.\n", "infix `\u21a6` :50 := morphism\n", "We want to define composition of morphisms, so your first task is to prove that the\ncompatability condition needed holds when we do the `obvious' thing ... you will want \nto use the result sym2.map_comp.\n", "For all graphs $G$, $H$ and $K$ and for all morphisms $\u03b1 : G \u2192 H$ and $\u03b2 : H \u2192 K$, we have\n$\u03b5_K \u2218 \u03b2_e \u2218 \u03b1_e = sym2 (\u03b2_v \u2218 \u03b1_v) \u2218 \u03b5_G$.\n", "import graphs.definitions\n", "Now that we know the compatability condition holds, we can go ahead and \ndefine composition of morphisms.\n", "def compose {G H K : graph} (\u03b2 : H \u21a6 K) (\u03b1 : G \u21a6 H) : G \u21a6 K :=\n  morphism.mk (\u03b2.vertex_map \u2218 \u03b1.vertex_map) (\u03b2.edge_map \u2218 \u03b1.edge_map) (by exact compatability \u03b1 \u03b2)\n", "We want a convenient infix operator for composition of morphisms.\n", "infix `\u229a`:80 := compose\n", "Proving associativity of composition is now trivial ...\n", "For all morphisms $\u03b1 : G \u2192 H$, $\u03b2 : H \u2192 K$ and $\u03b3 : K \u2192 L$, we have\n$\u03b3 \u2218 (\u03b2 \u2218 \u03b1) = (\u03b3 \u2218 \u03b2) \u2218 \u03b1$.\n", "import graphs.composition\n", "We want to define the identity morphism, but that requires a compatability proof.  \nYou will need to use sym2.map_id.\n", "", "import graphs.id\n", "Now we can define the identity morphism.\n", "def \ud835\udd40 (G : graph) : G \u21a6 G :=\n  morphism.mk (id) (id) (by exact id_compatability G)\n", "Next we turn our attention to defining an isomorphism.\n", "def isomorphism {G H : graph} (\u03b1 : G \u21a6 H) : Prop :=\n  \u2203 \u03b2 : H \u21a6 G, \u03b1 \u229a \u03b2 = \ud835\udd40 H \u2227 \u03b2 \u229a \u03b1 = \ud835\udd40 G\n", "This is a sanity check: proving that the identity is an isomorphism.\n", "", "import graphs.iso\n", "Proving equality on structures is a pain, so we should prove an extensionality\ntheorem.  Basically, it suffices for the respective vertex maps and edge maps to \nbe equal.\n\nYou will need to use cases to write out \u03b1 and \u03b2, and then rewrite with \nmorphism.mk.inj_eq, which splits the equality of structures into separate goals.\n", "", "import graphs.ext\n", "The next two are helpful so that we don't have to keep repeating silly proofs.\nBasically, we show that equal morphisms have equal vertex maps and edge maps \nusing essentially the same argument as for our more general extensionality \ntheorem.\n", "", "import graphs.ext\n", "We prove the same for vertex maps ...\n", "", "import graphs.allexts\nopen function -- allows us to use key results about functions\n", "Our final two results are proving that a morphism is an isomorphism if and\nonly if the vertex map and edge map are both bijective.  Of course, we are\nleaning very heavily on the corresponding results for functions.\n\nYou will probably want to use the definitions of left_inverse and right_inverse \nand to apply the results left_inverse.injective and right_inverse.surjective.\n", "", "import graphs.allexts\nopen function -- allows us to use key results about functions\n", "... and now for the converse ...\n", ""]]}